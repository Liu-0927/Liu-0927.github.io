<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>清风的第一篇博客</title>
    <url>/2023/11/08/%E6%B8%85%E9%A3%8E%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[]]></content>
      <tags>
        <tag>工具</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题记录-数组</title>
    <url>/2023/11/13/leetcode-%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h2 id="数组理论基础"><a href="#数组理论基础" class="headerlink" title="数组理论基础"></a>数组理论基础</h2><p><strong>数组是存放在连续内存空间上的相同类型数据的集合</strong></p>
<p>需要两点注意的是</p>
<ul>
<li><strong>数组下标都是从0开始的。</strong></li>
<li><strong>数组内存空间的地址是连续的</strong></li>
</ul>
<p><strong>因为数组的在内存空间的地址是连续 的，所以我们在删除或者增添元素的时候，就难免要移动其他元素的地址。</strong></p>
<p><strong>数组的元素是不能删的，只能覆盖。</strong></p>
<h2 id="704-二分查找"><a href="#704-二分查找" class="headerlink" title="704.二分查找"></a>704.二分查找</h2><p><img src="https://cdn.jsdelivr.net/gh/Liu-0927/images/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-11-15%20215348.png" alt="image-20231115215351857"></p>
<p><strong>重点：</strong>要分清区间，在循环中始终坚持根据查找区间的定义来做边界处理</p>
<p>分俩种情况</p>
<p>1.左闭右闭区间[left,right]</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> left=<span class="number">0</span>,right=nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;=right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> mid=(right-left)/<span class="number">2</span>+left;<span class="comment">//防止溢出 等同于(left + right)/2</span></span><br><span class="line">            <span class="type">int</span> num=nums[mid];</span><br><span class="line">            <span class="keyword">if</span>(num==target)</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(num&gt;target)</span><br><span class="line">            right=mid<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            left=mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>2.左闭右开区间[left,right)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> right = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123; <span class="comment">// 因为left == right的时候，在[left, right)是无效的空间，所以使用 &lt;</span></span><br><span class="line">            <span class="type">int</span> middle = left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (nums[middle] &gt; target) &#123;</span><br><span class="line">                right = middle; </span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[middle] &lt; target) &#123;</span><br><span class="line">                left = middle + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> middle;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="27-移除元素"><a href="#27-移除元素" class="headerlink" title="27.移除元素"></a>27.移除元素</h2><p><img src="https://cdn.jsdelivr.net/gh/Liu-0927/images/image-20231116194854823.png"></p>
<p>本题用到双指针法</p>
<p>双指针：<strong>通过一个快指针和慢指针在一个for循环下完成两个for循环的工作</strong></p>
<p>定义快慢指针</p>
<ul>
<li>快指针：寻找新数组的元素 ，新数组就是不含有目标元素的数组</li>
<li>慢指针：指向更新 新数组下标的位置</li>
</ul>
<p><strong>双指针法（快慢指针法）在数组和链表的操作中是非常常见的，很多考察数组、链表、字符串等操作的面试题，都使用双指针法。</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">removeElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> val)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> left=<span class="number">0</span>,right=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[left]==val)</span><br><span class="line">            &#123;</span><br><span class="line">                nums[left]=nums[right<span class="number">-1</span>];</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="977-有序数组的平方"><a href="#977-有序数组的平方" class="headerlink" title="977.有序数组的平方"></a>977.有序数组的平方</h2><p><img src="https://cdn.jsdelivr.net/gh/Liu-0927/images/image-20231128173318107.png" alt="image-20231128173318107"></p>
<p>法一(暴力法)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sortedSquares</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            nums[i]=nums[i]*nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>法二(双指针)</p>
<p>数组其实是有序的， 只不过负数平方之后可能成为最大数了。</p>
<p>那么数组平方的最大值就在数组的两端，不是最左边就是最右边，不可能是中间。</p>
<p>此时可以考虑双指针法了，p指向起始位置，q指向终止位置。</p>
<p>定义一个新数组nusm2，和nums数组一样的大小，让k指向result数组终止位置。</p>
<p>如果<code>nums[p] * nums[p] &lt;= nums[q] * nums[q]</code> 那么<code>nums2[k--] = nums[q] * nums[q];</code> 。</p>
<p>如果<code>nums[i] * nums[p] &gt; nums[q] * nusms[q]</code> 那么<code>nums2[k--] = nums[p] * nums[p];</code> 。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sortedSquares</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> p=<span class="number">0</span>,q=nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> k=nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;<span class="built_in">nums2</span>(nums.<span class="built_in">size</span>(),<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">while</span>(p&lt;=q)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[p]*nums[p]&lt;=nums[q]*nums[q])</span><br><span class="line">            &#123;</span><br><span class="line">                nums2[k--]=nums[q]*nums[q];</span><br><span class="line">                q--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                nums2[k--]=nums[p]*nums[p];</span><br><span class="line">                p++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="209-长度最小的子数组"><a href="#209-长度最小的子数组" class="headerlink" title="209.长度最小的子数组"></a>209.长度最小的子数组</h2><p><img src="https://cdn.jsdelivr.net/gh/Liu-0927/images/image-20231128174231331.png" alt="image-20231128174231331"></p>
]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>测试博客</title>
    <url>/2023/11/08/%E6%B5%8B%E8%AF%95%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<p>1</p>
<p>这是一篇测试博客</p>
]]></content>
  </entry>
</search>
