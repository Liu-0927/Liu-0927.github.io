<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>leetcode刷题记录-数组</title>
    <url>/2023/11/13/leetcode-%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h2 id="数组理论基础"><a href="#数组理论基础" class="headerlink" title="数组理论基础"></a>数组理论基础</h2><p><strong>数组是存放在连续内存空间上的相同类型数据的集合</strong></p>
<p>需要两点注意的是</p>
<ul>
<li><strong>数组下标都是从0开始的。</strong></li>
<li><strong>数组内存空间的地址是连续的</strong></li>
</ul>
<p><strong>因为数组的在内存空间的地址是连续 的，所以我们在删除或者增添元素的时候，就难免要移动其他元素的地址。</strong></p>
<p><strong>数组的元素是不能删的，只能覆盖。</strong></p>
<h2 id="704-二分查找"><a href="#704-二分查找" class="headerlink" title="704.二分查找"></a>704.二分查找</h2><p><img src="https://cdn.jsdelivr.net/gh/Liu-0927/images/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-11-15%20215348.png" alt="image-20231115215351857"></p>
<p><strong>重点：</strong>要分清区间，在循环中始终坚持根据查找区间的定义来做边界处理</p>
<p>分俩种情况</p>
<p>1.左闭右闭区间[left,right]</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> left=<span class="number">0</span>,right=nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;=right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> mid=(right-left)/<span class="number">2</span>+left;<span class="comment">//防止溢出 等同于(left + right)/2</span></span><br><span class="line">            <span class="type">int</span> num=nums[mid];</span><br><span class="line">            <span class="keyword">if</span>(num==target)</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(num&gt;target)</span><br><span class="line">            right=mid<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            left=mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>2.左闭右开区间[left,right)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> right = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123; <span class="comment">// 因为left == right的时候，在[left, right)是无效的空间，所以使用 &lt;</span></span><br><span class="line">            <span class="type">int</span> middle = left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (nums[middle] &gt; target) &#123;</span><br><span class="line">                right = middle; </span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[middle] &lt; target) &#123;</span><br><span class="line">                left = middle + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> middle;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="27-移除元素"><a href="#27-移除元素" class="headerlink" title="27.移除元素"></a>27.移除元素</h2><p><img src="https://cdn.jsdelivr.net/gh/Liu-0927/images/image-20231116194854823.png"></p>
<p>本题用到双指针法</p>
<p>双指针：<strong>通过一个快指针和慢指针在一个for循环下完成两个for循环的工作</strong></p>
<p>定义快慢指针</p>
<ul>
<li>快指针：寻找新数组的元素 ，新数组就是不含有目标元素的数组</li>
<li>慢指针：指向更新 新数组下标的位置</li>
</ul>
<p><strong>双指针法（快慢指针法）在数组和链表的操作中是非常常见的，很多考察数组、链表、字符串等操作的面试题，都使用双指针法。</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">removeElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> val)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> left=<span class="number">0</span>,right=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[left]==val)</span><br><span class="line">            &#123;</span><br><span class="line">                nums[left]=nums[right<span class="number">-1</span>];</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="977-有序数组的平方"><a href="#977-有序数组的平方" class="headerlink" title="977.有序数组的平方"></a>977.有序数组的平方</h2><p><img src="https://cdn.jsdelivr.net/gh/Liu-0927/images/image-20231128173318107.png" alt="image-20231128173318107"></p>
<p>法一(暴力法)</p>
<p>直接把数组内的每个元素平方后再排序</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sortedSquares</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            nums[i]=nums[i]*nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>法二(双指针)</p>
<p>数组其实是有序的， 只不过负数平方之后可能成为最大数了。</p>
<p>那么数组平方的最大值就在数组的两端，不是最左边就是最右边，不可能是中间。</p>
<p>此时可以考虑双指针法了，p指向起始位置，q指向终止位置。</p>
<p>定义一个新数组nusm2，和nums数组一样的大小，让k指向result数组终止位置。</p>
<p>如果<code>nums[p] * nums[p] &lt;= nums[q] * nums[q]</code> 那么<code>nums2[k--] = nums[q] * nums[q];</code> 。</p>
<p>如果<code>nums[i] * nums[p] &gt; nums[q] * nusms[q]</code> 那么<code>nums2[k--] = nums[p] * nums[p];</code> 。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sortedSquares</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> p=<span class="number">0</span>,q=nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> k=nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;<span class="built_in">nums2</span>(nums.<span class="built_in">size</span>(),<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">while</span>(p&lt;=q)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[p]*nums[p]&lt;=nums[q]*nums[q])</span><br><span class="line">            &#123;</span><br><span class="line">                nums2[k--]=nums[q]*nums[q];</span><br><span class="line">                q--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                nums2[k--]=nums[p]*nums[p];</span><br><span class="line">                p++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="209-长度最小的子数组"><a href="#209-长度最小的子数组" class="headerlink" title="209.长度最小的子数组"></a>209.长度最小的子数组</h2><p><img src="https://cdn.jsdelivr.net/gh/Liu-0927/images/image-20231128174231331.png" alt="image-20231128174231331"></p>
<p>法一(暴力法)</p>
<p>直接使用双层for循环，i指向子数组的起始位置，j指向子数组的终止位置，循环寻找符合题意的最小子数组</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> result=INT_MAX;</span><br><span class="line">        <span class="type">int</span> subLength=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;nums.<span class="built_in">size</span>();j++)</span><br><span class="line">            &#123;</span><br><span class="line">                sum+=nums[j];</span><br><span class="line">                <span class="keyword">if</span>(sum&gt;=target)</span><br><span class="line">                &#123;</span><br><span class="line">                    subLength=j-i+<span class="number">1</span>;</span><br><span class="line">                    result=result&lt;subLength?result:subLength;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result==INT_MAX?<span class="number">0</span>:result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>法二(滑动窗口)</p>
<p><strong>滑动窗口</strong>：定义俩个指针i,j。i指向窗口起始位置，j指向窗口终止位置。先固定i，然后j向后遍历，期间将遍历过的元素和赋值给sum，当发现sum大于或等于目标值时，将此时的窗口长度保存下来，将sum减去当前i指向的元素，并将i向后移动一位(窗口向后移动)，循环往复，直到找到符合题意的最小长度子序列。</p>
<p><strong>滑动窗口的精妙之处在于根据当前子序列和大小的情况，不断调节子序列的起始位置。从而将O(n^2)暴力解法降为O(n)</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">		<span class="type">int</span> result=INT_MAX;</span><br><span class="line">        <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> subLength=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;nums.<span class="built_in">size</span>();j++)</span><br><span class="line">        &#123;</span><br><span class="line">            sum+=nums[j];</span><br><span class="line">            <span class="keyword">while</span>(sum&gt;=target)<span class="comment">//不能用if，举例[1,1,1,1,100]</span></span><br><span class="line">            &#123;</span><br><span class="line">                subLength=(j-i+<span class="number">1</span>);</span><br><span class="line">                result=result&lt;subLength?result:subLength;</span><br><span class="line">                sum-=nums[i++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result==INT_MAX?<span class="number">0</span>:result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="59-螺旋矩阵II"><a href="#59-螺旋矩阵II" class="headerlink" title="59.螺旋矩阵II"></a>59.螺旋矩阵II</h2><p><img src="https://cdn.jsdelivr.net/gh/Liu-0927/images/image-20231129214721561.png" alt="image-20231129214721561"></p>
<p>本题解题重点在于对区间的把控。每条边单独处理，保持循环不变量原则。将每条边的最后一个值交给下条边作为初始值来处理。</p>
<p>思路：</p>
<p>定义一个二维数组，用来存放循环出的矩阵，定义：startx,starty赋初值为0，表示起始下标(0,0)；offset用来控制每条边所遍历的长度，每转完一圈，需要动态减一；count表示填充到每个位置的值；loop用来控制while循环的次数，即圈数；mid用来表示当n为奇数时的中心下标(mid,mid)；i，j用来表示遍历下标。</p>
<p>进入到循环后，给i，j赋初值，第一个for用来遍历最上边的边，之后依次为最右边，最下边，最左边。每次循环完一圈后，需要给startx,starty加一，来进行下一圈的循环。因为每次都会往里边缩一位，所以offset需要加一。</p>
<p>最后判断n是奇数还是偶数，如果是奇数，需要对中心赋值，偶数的话当while循环结束后就填满了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">generateMatrix</span>(<span class="type">int</span> n) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//vector&lt;int&gt;(n, 0)表示一个大小为n的一维vector，其中所有元素初始化为0。然后，外层的vector&lt;vector&lt;int&gt;&gt; res(n, ...)使用这个一维vector作为初始值，创建了n个拷贝，形成了一个大小为n * n的二维vector</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">nums</span>(n,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n,<span class="number">0</span>));</span><br><span class="line">        <span class="type">int</span> startx=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> starty=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> offset=<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> count=<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> loop=n/<span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> mid=n/<span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> i,j;</span><br><span class="line">        <span class="keyword">while</span>(loop--)</span><br><span class="line">        &#123;</span><br><span class="line">            i=startx;</span><br><span class="line">            j=starty;</span><br><span class="line">            <span class="keyword">for</span>(j=starty;j&lt;n-offset;j++)&#123;</span><br><span class="line">                nums[startx][j]=count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(i=startx;i&lt;n-offset;i++)&#123;</span><br><span class="line">                nums[i][j]=count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(;j&gt;starty;j--)&#123;</span><br><span class="line">                nums[i][j]=count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(;i&gt;startx;i--)&#123;</span><br><span class="line">                nums[i][j]=count++;</span><br><span class="line">            &#125;</span><br><span class="line">            startx++;</span><br><span class="line">            starty++;</span><br><span class="line">            offset+=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(n%<span class="number">2</span>==<span class="number">1</span>)</span><br><span class="line">        nums[mid][mid]=count;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>测试博客</title>
    <url>/2023/11/08/%E6%B5%8B%E8%AF%95%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<p>1</p>
<p>这是一篇测试博客</p>
]]></content>
  </entry>
  <entry>
    <title>清风的第一篇博客</title>
    <url>/2023/11/08/%E6%B8%85%E9%A3%8E%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[]]></content>
      <tags>
        <tag>工具</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
