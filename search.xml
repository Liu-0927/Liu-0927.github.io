<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>leetcode刷题记录-数组</title>
    <url>/2023/11/13/leetcode-%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h2 id="数组理论基础"><a href="#数组理论基础" class="headerlink" title="数组理论基础"></a>数组理论基础</h2><p><strong>数组是存放在连续内存空间上的相同类型数据的集合</strong></p>
<p>需要两点注意的是</p>
<ul>
<li><strong>数组下标都是从0开始的。</strong></li>
<li><strong>数组内存空间的地址是连续的</strong></li>
</ul>
<p><strong>因为数组的在内存空间的地址是连续 的，所以我们在删除或者增添元素的时候，就难免要移动其他元素的地址。</strong></p>
<p><strong>数组的元素是不能删的，只能覆盖。</strong></p>
<h2 id="704-二分查找"><a href="#704-二分查找" class="headerlink" title="704.二分查找"></a>704.二分查找</h2><p><img src="https://cdn.jsdelivr.net/gh/Liu-0927/images/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-11-15%20215348.png" alt="image-20231115215351857"></p>
<p><strong>重点：</strong>要分清区间，在循环中始终坚持根据查找区间的定义来做边界处理</p>
<p>思路：</p>
<p>因为数组有序且无重复元素，所以可以考虑使用二分法，定义俩个指针left，right，分别指向数组的起始和末尾位置，进入循环定义一个变量mid作为区间的中间下标，记录下中间下标的值。然后判断，如果此时中间下标的值正好等于目标值，直接返回mid；如果此时的中值大于目标值，那么目标值应该在前半区间内，此时将右指针指向中间；如果中值小于目标值，那么目标值应该在下半区间内，此时将左指针指向中间，照此逻辑一直循环。</p>
<p>分俩种情况</p>
<p>1.左闭右闭区间[left,right]</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> left=<span class="number">0</span>,right=nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;=right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> mid=(right-left)/<span class="number">2</span>+left;<span class="comment">//防止溢出 等同于(left + right)/2</span></span><br><span class="line">            <span class="type">int</span> num=nums[mid];</span><br><span class="line">            <span class="keyword">if</span>(num==target)</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(num&gt;target)</span><br><span class="line">            right=mid<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            left=mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>2.左闭右开区间[left,right)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> right = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123; <span class="comment">// 因为left == right的时候，在[left, right)是无效的空间，所以使用 &lt;</span></span><br><span class="line">            <span class="type">int</span> middle = left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (nums[middle] &gt; target) &#123;</span><br><span class="line">                right = middle; </span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[middle] &lt; target) &#123;</span><br><span class="line">                left = middle + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> middle;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="27-移除元素"><a href="#27-移除元素" class="headerlink" title="27.移除元素"></a>27.移除元素</h2><p><img src="https://cdn.jsdelivr.net/gh/Liu-0927/images/image-20231116194854823.png"></p>
<p>本题用到双指针法</p>
<p>双指针：<strong>通过一个快指针和慢指针在一个for循环下完成两个for循环的工作</strong></p>
<p>定义快慢指针</p>
<ul>
<li>快指针：寻找新数组的元素 ，新数组就是不含有目标元素的数组</li>
<li>慢指针：指向更新 新数组下标的位置</li>
</ul>
<p><strong>双指针法（快慢指针法）在数组和链表的操作中是非常常见的，很多考察数组、链表、字符串等操作的面试题，都使用双指针法。</strong></p>
<p>思路：</p>
<p>定义俩个指针left,right，left指向数组首个元素，right指向数组最后一个元素，进行遍历，当left的值等于val时，把right指向的值和left的互换，然后right指针左移，否则，left指针右移，直到左右指针相等</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">removeElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> val)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> left=<span class="number">0</span>,right=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[left]==val)</span><br><span class="line">            &#123;</span><br><span class="line">                nums[left]=nums[right<span class="number">-1</span>];</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="977-有序数组的平方"><a href="#977-有序数组的平方" class="headerlink" title="977.有序数组的平方"></a>977.有序数组的平方</h2><p><img src="https://cdn.jsdelivr.net/gh/Liu-0927/images/image-20231128173318107.png" alt="image-20231128173318107"></p>
<p>法一(暴力法)</p>
<p>直接把数组内的每个元素平方后再排序</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sortedSquares</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            nums[i]=nums[i]*nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>法二(双指针)</p>
<p>数组其实是有序的， 只不过负数平方之后可能成为最大数了。</p>
<p>那么数组平方的最大值就在数组的两端，不是最左边就是最右边，不可能是中间。</p>
<p>此时可以考虑双指针法了，p指向起始位置，q指向终止位置。</p>
<p>定义一个新数组nusm2，和nums数组一样的大小，让k指向result数组终止位置。</p>
<p>如果<code>nums[p] * nums[p] &lt;= nums[q] * nums[q]</code> 那么<code>nums2[k--] = nums[q] * nums[q];</code> 。</p>
<p>如果<code>nums[i] * nums[p] &gt; nums[q] * nusms[q]</code> 那么<code>nums2[k--] = nums[p] * nums[p];</code> 。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sortedSquares</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> p=<span class="number">0</span>,q=nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> k=nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;<span class="built_in">nums2</span>(nums.<span class="built_in">size</span>(),<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">while</span>(p&lt;=q)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[p]*nums[p]&lt;=nums[q]*nums[q])</span><br><span class="line">            &#123;</span><br><span class="line">                nums2[k--]=nums[q]*nums[q];</span><br><span class="line">                q--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                nums2[k--]=nums[p]*nums[p];</span><br><span class="line">                p++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="209-长度最小的子数组"><a href="#209-长度最小的子数组" class="headerlink" title="209.长度最小的子数组"></a>209.长度最小的子数组</h2><p><img src="https://cdn.jsdelivr.net/gh/Liu-0927/images/image-20231128174231331.png" alt="image-20231128174231331"></p>
<p>法一(暴力法)</p>
<p>直接使用双层for循环，i指向子数组的起始位置，j指向子数组的终止位置，循环寻找符合题意的最小子数组</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> result=INT_MAX;</span><br><span class="line">        <span class="type">int</span> subLength=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;nums.<span class="built_in">size</span>();j++)</span><br><span class="line">            &#123;</span><br><span class="line">                sum+=nums[j];</span><br><span class="line">                <span class="keyword">if</span>(sum&gt;=target)</span><br><span class="line">                &#123;</span><br><span class="line">                    subLength=j-i+<span class="number">1</span>;</span><br><span class="line">                    result=result&lt;subLength?result:subLength;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result==INT_MAX?<span class="number">0</span>:result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>法二(滑动窗口)</p>
<p><strong>滑动窗口</strong>：定义俩个指针i,j。i指向窗口起始位置，j指向窗口终止位置。先固定i，然后j向后遍历，期间将遍历过的元素和赋值给sum，当发现sum大于或等于目标值时，将此时的窗口长度保存下来，将sum减去当前i指向的元素，并将i向后移动一位(窗口向后移动)，循环往复，直到找到符合题意的最小长度子序列。</p>
<p><strong>滑动窗口的精妙之处在于根据当前子序列和大小的情况，不断调节子序列的起始位置。从而将O(n^2)暴力解法降为O(n)</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">		<span class="type">int</span> result=INT_MAX;</span><br><span class="line">        <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> subLength=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;nums.<span class="built_in">size</span>();j++)</span><br><span class="line">        &#123;</span><br><span class="line">            sum+=nums[j];</span><br><span class="line">            <span class="keyword">while</span>(sum&gt;=target)<span class="comment">//不能用if，举例[1,1,1,1,100]</span></span><br><span class="line">            &#123;</span><br><span class="line">                subLength=(j-i+<span class="number">1</span>);</span><br><span class="line">                result=result&lt;subLength?result:subLength;</span><br><span class="line">                sum-=nums[i++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result==INT_MAX?<span class="number">0</span>:result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="59-螺旋矩阵II"><a href="#59-螺旋矩阵II" class="headerlink" title="59.螺旋矩阵II"></a>59.螺旋矩阵II</h2><p><img src="https://cdn.jsdelivr.net/gh/Liu-0927/images/image-20231129214721561.png" alt="image-20231129214721561"></p>
<p>本题解题重点在于对区间的把控。每条边单独处理，保持循环不变量原则。将每条边的最后一个值交给下条边作为初始值来处理。</p>
<p>思路：</p>
<p>定义一个二维数组，用来存放循环出的矩阵，定义：startx,starty赋初值为0，表示起始下标(0,0)；offset用来控制每条边所遍历的长度，每转完一圈，需要动态减一；count表示填充到每个位置的值；loop用来控制while循环的次数，即圈数；mid用来表示当n为奇数时的中心下标(mid,mid)；i，j用来表示遍历下标。</p>
<p>进入到循环后，给i，j赋初值，第一个for用来遍历最上边的边，之后依次为最右边，最下边，最左边。每次循环完一圈后，需要给startx,starty加一，来进行下一圈的循环。因为每次都会往里边缩一位，所以offset需要加一。</p>
<p>最后判断n是奇数还是偶数，如果是奇数，需要对中心赋值，偶数的话当while循环结束后就填满了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">generateMatrix</span>(<span class="type">int</span> n) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//vector&lt;int&gt;(n, 0)表示一个大小为n的一维vector，其中所有元素初始化为0。然后，外层的vector&lt;vector&lt;int&gt;&gt; res(n, ...)使用这个一维vector作为初始值，创建了n个拷贝，形成了一个大小为n * n的二维vector</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">nums</span>(n,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n,<span class="number">0</span>));</span><br><span class="line">        <span class="type">int</span> startx=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> starty=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> offset=<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> count=<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> loop=n/<span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> mid=n/<span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> i,j;</span><br><span class="line">        <span class="keyword">while</span>(loop--)</span><br><span class="line">        &#123;</span><br><span class="line">            i=startx;</span><br><span class="line">            j=starty;</span><br><span class="line">            <span class="keyword">for</span>(j=starty;j&lt;n-offset;j++)&#123;</span><br><span class="line">                nums[startx][j]=count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(i=startx;i&lt;n-offset;i++)&#123;</span><br><span class="line">                nums[i][j]=count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(;j&gt;starty;j--)&#123;</span><br><span class="line">                nums[i][j]=count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(;i&gt;startx;i--)&#123;</span><br><span class="line">                nums[i][j]=count++;</span><br><span class="line">            &#125;</span><br><span class="line">            startx++;</span><br><span class="line">            starty++;</span><br><span class="line">            offset+=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(n%<span class="number">2</span>==<span class="number">1</span>)</span><br><span class="line">        nums[mid][mid]=count;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题记录-链表</title>
    <url>/2023/11/30/leetcode-%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="链表理论基础"><a href="#链表理论基础" class="headerlink" title="链表理论基础"></a>链表理论基础</h2><p>链表是一种通过指针串联在一起的线性结构，链表的入口节点称为链表的头结点也就是head。链表在内存中是随机分布的，通过指针域的指针链接在内存中各个节点，分配机制取决于操作系统的内存管理。</p>
<p><strong>链表的分类</strong></p>
<p>单链表，双链表，循环链表。</p>
<p><strong>单链表</strong>：数据域，指针域(下个节点的地址)</p>
<p><strong>双链表</strong>：指针域(前个节点的地址)，数据域，指针域(下个节点的地址)</p>
<p><strong>循环链表</strong>：首位相连的链表，可用来解决约瑟夫环问题</p>
<p>c&#x2F;c++的定义链表节点方式：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 单链表</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;  <span class="comment">// 节点上存储的元素</span></span><br><span class="line">    ListNode *next;  <span class="comment">// 指向下一个节点的指针</span></span><br><span class="line">    <span class="built_in">ListNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">next</span>(<span class="literal">NULL</span>) &#123;&#125;  <span class="comment">// 节点的构造函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="203-移除链表元素"><a href="#203-移除链表元素" class="headerlink" title="203.移除链表元素"></a>203.移除链表元素</h2><p><img src="https://cdn.jsdelivr.net/gh/Liu-0927/images/image-20231130164855483.png" alt="image-20231130164855483"></p>
<p>思路：设置虚拟头节点，因为如果直接用原头节点操作的话，删除头节点需要单独处理，所以使用虚拟头节点，这样所有的元素操作起来都是一个方法。</p>
<p>首先设置虚拟头节点，让它指向原本的头节点，再定义一个指针cur使之指向虚拟头节点，然后开始遍历，如果发现了要删除的节点，定义一个新的指针tmp指向将要删除的节点，然后进行删除操作，最后重新设置头节点，把虚拟头节点删除。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeElements</span><span class="params">(ListNode* head, <span class="type">int</span> val)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ListNode*dummyHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);<span class="comment">//设置一个虚拟的头节点</span></span><br><span class="line">        dummyHead-&gt;next=head;</span><br><span class="line">        ListNode*cur=dummyHead;<span class="comment">//指向虚拟头节点</span></span><br><span class="line">        <span class="keyword">while</span>(cur-&gt;next!=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;next-&gt;val==val)</span><br><span class="line">            &#123;</span><br><span class="line">                ListNode*tmp=cur-&gt;next;<span class="comment">//指向欲删除节点</span></span><br><span class="line">                cur-&gt;next=cur-&gt;next-&gt;next;</span><br><span class="line">                <span class="keyword">delete</span> tmp;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                cur=cur-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        head=dummyHead-&gt;next;<span class="comment">//重新设置头节点</span></span><br><span class="line">        <span class="keyword">delete</span> dummyHead;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="707-设计链表"><a href="#707-设计链表" class="headerlink" title="707.设计链表"></a>707.设计链表</h2><p><img src="https://cdn.jsdelivr.net/gh/Liu-0927/images/image-20231130194305373.png" alt="image-20231130194305373"></p>
<p>思路：</p>
<p>定义链表结点结构体LinkedNode，定义虚拟头节点dummyHead，这样就可以像操作数组一样来操作</p>
<p>get函数：</p>
<p>先判断index是否有效，小于0或超出链表长度均为无效。然后定义一个指针cur指向虚拟头节点的下一个节点，也就是真正的头节点，进行遍历，最后输出目标值。</p>
<p>addAtHead函数：</p>
<p>定义一个新节点，然后先让新节点指向头节点，再让虚拟头节点指向新节点，最后增加链表长度。<strong>注意</strong>：必须要先连接2，再连接1，如果先连接1，那么3会断开，导致找不到dummyHead–&gt;next，如图</p>
<p><img src="https://cdn.jsdelivr.net/gh/Liu-0927/images/image-20231130202106463.png" alt="image-20231130202106463"></p>
<p>addAtTail函数：</p>
<p>定义一个新节点，定义一个新的指针cur，指向虚拟头节点，循环一直到cur-&gt;next为空，此时cur指向了链表的最后一个元素，然后将cur-&gt;next指向新节点，最后加长链表长度。</p>
<p>addAtIndex函数：</p>
<p>判断index的合法性，如果超出了链表长度，那么就直接返回空值，如果为0，则是加到链表头部，如果等于链表长度，则加到链表的尾部，如果小于0，则加到链表的头部。然后定义一个指针cur指向虚拟头节点，定义新节点。进入循环，让cur指向要插入位置的前一个节点，之后先让新节点指向后一个节点，再让前一个节点指向新节点(必须按照这个步骤，原因参考addAtHead函数)，最后加长链表长度。</p>
<p>deleteAtIndex函数：</p>
<p>先判断index的合法性，然后定义指针cur指向虚拟头节点，进入循环，遍历到要删除节点的前一个节点，然后定义一个新的指针tmp指向要删除的节点，接着进行链表删除的操作，最后需要将tmp设为空值，因为tmp删除后，tmp会成为野指针，指向随机地址。加长链表长度。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyLinkedList</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">LinkedNode</span>&#123;</span><br><span class="line">        <span class="type">int</span> val;</span><br><span class="line">        LinkedNode *next;</span><br><span class="line">        <span class="built_in">LinkedNode</span>(<span class="type">int</span> val):<span class="built_in">val</span>(val),<span class="built_in">next</span>(<span class="literal">NULL</span>)&#123;&#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    LinkedNode* dummyHead;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyLinkedList</span>() &#123;</span><br><span class="line">        dummyHead=<span class="keyword">new</span> <span class="built_in">LinkedNode</span>(<span class="number">0</span>);</span><br><span class="line">        size=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">index</span>&lt;<span class="number">0</span> || index&gt;(size<span class="number">-1</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        LinkedNode *cur=dummyHead-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(index--)</span><br><span class="line">        &#123;</span><br><span class="line">            cur=cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addAtHead</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        LinkedNode *newNode = <span class="keyword">new</span> <span class="built_in">LinkedNode</span>(val);</span><br><span class="line">        newNode-&gt;next=dummyHead-&gt;next;</span><br><span class="line">        dummyHead-&gt;next=newNode;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addAtTail</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        LinkedNode *newNode= <span class="keyword">new</span> <span class="built_in">LinkedNode</span>(val);</span><br><span class="line">        LinkedNode *cur=dummyHead;</span><br><span class="line">        <span class="keyword">while</span>(cur-&gt;next!=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cur=cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur-&gt;next=newNode;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addAtIndex</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index&gt;size)</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">        <span class="keyword">if</span>(index&lt;<span class="number">0</span>)</span><br><span class="line">        index=<span class="number">0</span>;</span><br><span class="line">        LinkedNode *cur=dummyHead;</span><br><span class="line">        LinkedNode *newNode=<span class="keyword">new</span> <span class="built_in">LinkedNode</span>(val);</span><br><span class="line">        <span class="keyword">while</span>(index--)</span><br><span class="line">        &#123;</span><br><span class="line">            cur=cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        newNode-&gt;next=cur-&gt;next;</span><br><span class="line">        cur-&gt;next=newNode;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">deleteAtIndex</span><span class="params">(<span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index&lt;<span class="number">0</span> || index&gt;=size)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">        LinkedNode *cur=dummyHead;</span><br><span class="line">        <span class="keyword">while</span>(index--)</span><br><span class="line">        &#123;</span><br><span class="line">            cur=cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        LinkedNode* tmp=cur-&gt;next;</span><br><span class="line">        cur-&gt;next=cur-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> tmp;</span><br><span class="line">        tmp=<span class="literal">NULL</span>;</span><br><span class="line">        size--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>测试博客</title>
    <url>/2023/11/08/%E6%B5%8B%E8%AF%95%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<p>1</p>
<p>这是一篇测试博客</p>
]]></content>
  </entry>
  <entry>
    <title>清风的第一篇博客</title>
    <url>/2023/11/08/%E6%B8%85%E9%A3%8E%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[]]></content>
      <tags>
        <tag>工具</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
